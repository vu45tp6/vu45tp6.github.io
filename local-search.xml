<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Stack and Queue</title>
    <link href="/2025/08/10/data%20structure/stackandqueue/"/>
    <url>/2025/08/10/data%20structure/stackandqueue/</url>
    
    <content type="html"><![CDATA[<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p><img src="/img/datastructure/chapone/1-2.png" alt="Stack"> </p><ul><li>Stack是一種先進後出（Last In First Out, LIFO）的資料結構。它的操作主要有兩個：<ol><li>push：將元素放入堆疊</li><li>pop：將元素從堆疊中取出</li></ol></li></ul><p><img src="/img/datastructure/chapone/1-3.png" alt="Representation of Stack"></p><p><img src="/img/datastructure/chapone/1-4.png" alt="Stack Example"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACKSIZE 100</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stack</span> &#123; <span class="hljs-comment">//宣告一個名為 stack 的結構</span><br>    <span class="hljs-comment">/*Data_Type*/</span><span class="hljs-type">int</span> items[STACKSIZE]; <span class="hljs-comment">// 存放堆疊元素的陣列</span><br>    <span class="hljs-type">int</span> top;    <span class="hljs-comment">// 紀錄目前堆疊頂端的index</span><br>&#125; s;            <span class="hljs-comment">//並同時建立變數 s</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Empty</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stack ps)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ps.top==<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果堆疊為空，返回 1</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 否則返回 0</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stack *ps)</span></span>&#123; <span class="hljs-comment">//回傳的資料型別(data type)是 int</span><br>    <span class="hljs-keyword">return</span> ps-&gt;items[ps-&gt;top--]; <span class="hljs-comment">// 返回堆疊頂端元素並將頂端指標下移</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Pop</code> 會回傳一個元素，因此函式的<strong>回傳型別</strong>為 <code>int</code>（表示會回傳整數）。</li><li><code>Pop</code> 直接操作<strong>原始堆疊</strong>：透過<strong>指標變數</strong> <code>ps</code>（型別為 <code>struct stack *</code>）傳入堆疊 <code>s</code> 的<strong>位址</strong>，函式內以 <code>ps-&gt;</code> 存取成員，會直接修改 <code>s</code>，而不是修改副本。<code>*ps</code> 則是「順著這個指標找到它指向的那個堆疊，整個拿出來看」，<code>ps-&gt;member</code> 等同於 <code>(*ps).member</code>。</li><li><code>ps-&gt;items[ps-&gt;top--]</code> 等價於 <code>(*ps).items[(*ps).top--]</code>：<ul><li><code>ps-&gt;items</code> 是在<strong>存取</strong>堆疊結構中的 <code>items</code> 陣列（不是「指向陣列的指標」的意思）。</li><li><code>ps-&gt;top--</code> 是<strong>後置遞減</strong>：先以目前的 <code>top</code> 做索引，取完值之後 <code>top</code> 再減一。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stack *ps, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    ps-&gt;items[++ps-&gt;top] = x; <span class="hljs-comment">// 將新元素放入堆疊頂端並上移頂端指標</span><br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 無返回值</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Push</code> 的參數 <code>int x</code> 表示要推入的元素型別；<code>struct stack *ps</code> 表示以指標將堆疊的<strong>位址</strong>傳入，函式內直接修改原堆疊內容。</li><li><code>Push</code> 直接操作<strong>原始堆疊</strong>：以指標參數 <code>ps</code>（<code>struct stack *</code>）傳入地址，透過 <code>ps-&gt;</code> 修改成員，不會產生副本。</li><li><code>++ps-&gt;top</code> 會先把 <code>top</code> 加一，再存放元素到新頂端。例如初值 <code>top = -1</code> 時，<code>++ps-&gt;top</code> 變為 <code>0</code>，元素會被放到 <code>items[0]</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Overflow</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stack ps)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ps.top==STACKSIZE<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果堆疊已滿，返回 1</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 否則返回 0</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stack</span> s; <span class="hljs-comment">// 宣告一個全域變數 s，類型為 stack 結構</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    s.top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化堆疊頂端指標為 -1，表示堆疊為空</span><br><br>    <span class="hljs-comment">// 範例操作</span><br>    <span class="hljs-built_in">Push</span>(&amp;s, <span class="hljs-number">10</span>); <span class="hljs-comment">// 將 10 推入堆疊</span><br>    <span class="hljs-built_in">Push</span>(&amp;s, <span class="hljs-number">20</span>); <span class="hljs-comment">// 將 20 推入堆疊</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Empty</span>(s)) &#123; <span class="hljs-comment">// 檢查堆疊是否為空</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆疊為空\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆疊不為空\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;彈出元素: %d\n&quot;</span>, <span class="hljs-built_in">Pop</span>(&amp;s)); <span class="hljs-comment">// 從堆疊彈出頂端元素並顯示</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;彈出元素: %d\n&quot;</span>, <span class="hljs-built_in">Pop</span>(&amp;s)); <span class="hljs-comment">// 再次從堆疊彈出頂端元素並顯示</span><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 程式結束</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在這個範例中，我們宣告了一個全域變數 <code>s</code>，類型為 <code>stack</code> 結構，並在 <code>main</code> 函式中將 <code>top</code> 設為 <code>-1</code> 以表示堆疊為空。接著進行基本操作：推入元素、檢查是否為空、彈出元素。<br>-（補充說明）此檔案同時在結構宣告結尾處以 <code>&#125; s;</code> 建立了變數 <code>s</code>，又在下方寫了 <code>struct stack s;</code>。實務上通常<strong>擇一</strong>即可；本文件保留原始程式碼不調整。</li><li><code>Push(&amp;s, 10)</code>、<code>Pop(&amp;s)</code>：<ul><li><code>&amp;s</code> 代表變數 <code>s</code> 的<strong>記憶體位址</strong>；以位址呼叫，函式會<strong>直接修改原始堆疊</strong>。</li><li><code>Push</code>&#x2F;<code>Pop</code> 的參數型別為 <code>struct stack *ps</code>，<code>ps</code> 會指向原本的 <code>s</code>；在函式內用 <code>ps-&gt;</code>（即 <code>(*ps).</code>）存取成員。</li></ul></li><li>在程式中呼叫 <code>Push(&amp;s, 10)</code> 和 <code>Pop(&amp;s)</code>，就是把堆疊 <code>s</code> 的位址傳入，使 <code>ps</code> 指向原堆疊；因此函式內的修改會反映在 <code>s</code> 上，而不是只改到副本。</li></ul><h2 id="Infix-Postfix-Prefix-Expression"><a href="#Infix-Postfix-Prefix-Expression" class="headerlink" title="Infix, Postfix, Prefix Expression"></a>Infix, Postfix, Prefix Expression</h2><ul><li><strong>Infix Expression</strong>: 操作符位於操作數之間，例如 <code>A + B</code>。</li><li><strong>Postfix Expression</strong>: 操作符位於操作數之後，例如 <code>AB+</code>（後序表示法）。</li><li><strong>Prefix Expression</strong>: 操作符位於操作數之前，例如 <code>+AB</code>（前序表示法）。</li><li>The prefix form is not the mirror image of the postfix form.</li></ul><p><img src="/img/datastructure/chapone/1-5.png"><br><img src="/img/datastructure/chapone/1-5.1.png"></p><ul><li>我們可以先將 infix 表示式畫成運算樹，然後再進行後序或前序的轉換。<ul><li>前序(prefix)：Preorder 走訪（先訪問節點，再走訪左右子樹）。</li><li>後序(postfix)：Postorder 走訪（先走訪左右子樹，最後訪問節點）。</li><li>中序(infix)：Inorder 走訪（先走訪左子樹，訪問節點，再走訪右子樹）。</li></ul></li></ul><p><img src="/img/datastructure/chapone/1-6.png"></p><h3 id="1-運算子優先序與結合性"><a href="#1-運算子優先序與結合性" class="headerlink" title="1. 運算子優先序與結合性"></a>1. 運算子優先序與結合性</h3><ul><li>優先序（由高到低）：<code>^</code> &gt; <code>* /</code> &gt; <code>+ -</code></li><li>結合性：<ul><li><code>^</code> 是<strong>右結合</strong>（<code>a ^ b ^ c</code> 會被當作 <code>a ^ (b ^ c)</code>）</li><li>其他如 <code>* / + -</code> 為左結合</li></ul></li><li>括號只用來覆寫運算順序，轉成 Postfix&#x2F;Prefix 後不會出現在結果中</li></ul><h3 id="2-Infix-→-Postfix-核心流程"><a href="#2-Infix-→-Postfix-核心流程" class="headerlink" title="2. Infix → Postfix 核心流程"></a>2. Infix → Postfix 核心流程</h3><p>使用一個 <strong>運算子堆疊</strong> 搭配輸出序列：</p><ol><li>運算元 → 直接加入輸出</li><li><code>(</code> → 推入運算子堆疊</li><li><code>)</code> → 將堆疊運算子彈出到輸出直到遇到 <code>(</code>，再將 <code>(</code> 丟掉</li><li>一般運算子 <code>op</code> →<ul><li>當棧頂運算子優先序 &gt; <code>op</code>，或（優先序相等且 <code>op</code> 為左結合）時，彈出棧頂到輸出</li><li>然後將 <code>op</code> 推入堆疊</li></ul></li><li>掃描結束後 → 將堆疊剩餘運算子依序彈出到輸出</li></ol><blockquote><p>注意 <code>^</code> 為右結合：遇到相同優先時不要先彈出</p></blockquote><h3 id="3-偽碼對照"><a href="#3-偽碼對照" class="headerlink" title="3. 偽碼對照"></a>3. 偽碼對照</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pseudo">for token in infix:<br>  if token is operand:<br>    output.append(token)<br>  else if token == &#x27;(&#x27;:<br>    op.push(token)<br>  else if token == &#x27;)&#x27;:<br>    while op.top() != &#x27;(&#x27;:<br>      output.append(op.pop())<br>    op.pop()<br>  else: # token 是運算子<br>    while op not empty and (<br>      prec(op.top()) &gt; prec(token) or<br>      (prec(op.top()) == prec(token) and is_left_assoc(token))<br>    ):<br>      output.append(op.pop())<br>    op.push(token)<br># end for<br>while op not empty:<br>  output.append(op.pop())<br></code></pre></td></tr></table></figure><h3 id="4-範例一：-A-C-B"><a href="#4-範例一：-A-C-B" class="headerlink" title="4. 範例一：(A + C) * B"></a>4. 範例一：(A + C) * B</h3><p>Tokens: <code>(</code> <code>A</code> <code>+</code> <code>C</code> <code>)</code> <code>*</code> <code>B</code></p><table><thead><tr><th>Token</th><th>運算子堆疊</th><th>輸出</th></tr></thead><tbody><tr><td>(</td><td>(</td><td></td></tr><tr><td>A</td><td>(</td><td>A</td></tr><tr><td>+</td><td>( +</td><td>A</td></tr><tr><td>C</td><td>( +</td><td>A C</td></tr><tr><td>)</td><td>( → pop <code>+</code></td><td>A C +</td></tr><tr><td>*</td><td>*</td><td>A C +</td></tr><tr><td>B</td><td>*</td><td>A C + B</td></tr><tr><td>end</td><td></td><td>A C + B *</td></tr></tbody></table><p>Postfix: <code>A C + B *</code></p><h3 id="5-範例二-完整-1-7-範例"><a href="#5-範例二-完整-1-7-範例" class="headerlink" title="5. 範例二 (完整 1-7 範例)"></a>5. 範例二 (完整 1-7 範例)</h3><p>Infix: <code>3 + 5 * 7 - ( 2 ^ 3 - 3 * 4 - ( 1 * 2 ) )</code></p><table><thead><tr><th>Token</th><th>運算子堆疊</th><th>輸出(Postfix)</th></tr></thead><tbody><tr><td>3</td><td></td><td>3</td></tr><tr><td>+</td><td>+</td><td>3</td></tr><tr><td>5</td><td>+</td><td>3 5</td></tr><tr><td>*</td><td>+ *</td><td>3 5</td></tr><tr><td>7</td><td>+ *</td><td>3 5 7</td></tr><tr><td>-</td><td>-</td><td>3 5 7 * +</td></tr><tr><td>(</td><td>- (</td><td>3 5 7 * +</td></tr><tr><td>2</td><td>- (</td><td>3 5 7 * + 2</td></tr><tr><td>^</td><td>- ( ^</td><td>3 5 7 * + 2</td></tr><tr><td>3</td><td>- ( ^</td><td>3 5 7 * + 2 3</td></tr><tr><td>-</td><td>- ( -</td><td>3 5 7 * + 2 3 ^</td></tr><tr><td>3</td><td>- ( -</td><td>3 5 7 * + 2 3 ^ 3</td></tr><tr><td>*</td><td>- ( - *</td><td>3 5 7 * + 2 3 ^ 3</td></tr><tr><td>4</td><td>- ( - *</td><td>3 5 7 * + 2 3 ^ 3 4</td></tr><tr><td>-</td><td>- ( -</td><td>3 5 7 * + 2 3 ^ 3 4 * -</td></tr><tr><td>(</td><td>- ( - (</td><td>3 5 7 * + 2 3 ^ 3 4 * -</td></tr><tr><td>1</td><td>- ( - (</td><td>3 5 7 * + 2 3 ^ 3 4 * - 1</td></tr><tr><td>*</td><td>- ( - ( *</td><td>3 5 7 * + 2 3 ^ 3 4 * - 1</td></tr><tr><td>2</td><td>- ( - ( *</td><td>3 5 7 * + 2 3 ^ 3 4 * - 1 2</td></tr><tr><td>)</td><td>- ( -</td><td>3 5 7 * + 2 3 ^ 3 4 * - 1 2 *</td></tr><tr><td>)</td><td>-</td><td>3 5 7 * + 2 3 ^ 3 4 * - 1 2 * -</td></tr><tr><td>end</td><td></td><td>3 5 7 * + 2 3 ^ 3 4 * - 1 2 * - -</td></tr></tbody></table><p>Postfix: <code>3 5 7 * + 2 3 ^ 3 4 * - 1 2 * - -</code></p><h3 id="6-Postfix-求值"><a href="#6-Postfix-求值" class="headerlink" title="6. Postfix 求值"></a>6. Postfix 求值</h3><p>演算法：</p><ol><li>由左到右讀取 token</li><li>運算元 → 推入值堆疊</li><li>運算子 → 依序彈出<strong>右運算元</strong>與<strong>左運算元</strong>，計算後推回堆疊</li><li>結束時堆疊頂即為答案</li></ol><p>範例計算：</p><ul><li><code>5 7 * → 35</code>，<code>3 35 + → 38</code></li><li><code>2 3 ^ → 8</code>，<code>3 4 * → 12</code>，<code>8 12 - → -4</code></li><li><code>1 2 * → 2</code>，<code>-4 2 - → -6</code></li><li><code>38 (-6) - → 44</code></li></ul><p>結果：<strong>44</strong></p>]]></content>
    
    
    <categories>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
      <tag>stack</tag>
      
      <tag>queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0050 v.s. 006208</title>
    <link href="/2025/08/08/006208/"/>
    <url>/2025/08/08/006208/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近收到006208的配息，就想到當初看完 <a href="https://www.books.com.tw/products/0010957881?sloc=main"><strong>持續買進</strong></a> 和 <a href="https://www.books.com.tw/products/0010955845?sloc=main"><strong>漫步華爾街</strong></a> 後，重新想了一下自己目前的的投資策略到底是怎，然後從原本定期定額的<strong>0050</strong>，轉向<strong>006208</strong>。</p><hr><h2 id="我的投資策略：長期持續買進"><a href="#我的投資策略：長期持續買進" class="headerlink" title="我的投資策略：長期持續買進"></a>我的投資策略：長期持續買進</h2><p>我的投資核心理念很簡單：<strong>不猜市場高低點，持續投入資金，讓資產穩定累積並抵抗通膨</strong>。</p><hr><h2 id="為什麼在0050和006208中選擇後者"><a href="#為什麼在0050和006208中選擇後者" class="headerlink" title="為什麼在0050和006208中選擇後者"></a>為什麼在0050和006208中選擇後者</h2><p>雖然0050和006208都是台股市值型的大盤ETF，成分股高度重疊，但配息來源結構是我選006208的原因。</p><h3 id="配息來源比較"><a href="#配息來源比較" class="headerlink" title="配息來源比較"></a>配息來源比較</h3><ul><li><strong>006208</strong>：配息<strong>100%來自54C（股利所得）</strong>，這代表配給我的現金，是真正來自成分股公司營運賺到的錢。資產本體（股票）依然留在市場中，繼續享受未來漲幅與股息。</li><li><strong>0050</strong>：配息中有一部分來自 <strong>76（資本利得）</strong>，意思是ETF賣掉一部分持股，把賣股票的價差配回給投資人。雖然資本利得在台灣不用課所得稅(<del>雖然我還不用繳所得稅</del>)，但對我來說，如果我不想在這個時候賣股，這筆配息等於減少了ETF的持股部位，<strong>犧牲未來的成長空間來換現金</strong>。對我這種現階段不需要額外現金流的人來說，這是資產淨值、時間成本、甚至是手續費的損失。</li></ul><h3 id="為什麼我在意配息來源"><a href="#為什麼我在意配息來源" class="headerlink" title="為什麼我在意配息來源"></a>為什麼我在意配息來源</h3><ul><li><strong>54C的好處</strong>：資產本體還在市場中運作，沒有被動用或減少持股，保有長期成長潛力與複利效果。</li><li><strong>76 的問題</strong>：減少持股，相當於提前套現一部分資產，長期來看是成長動能的流失。</li><li><strong>複利影響</strong>：若配息後沒有立即再投入，複利效果會被切斷；即使全額投入，也會遇到現金停留時間（領息到再買回）、交易手續費等額外成本，就是我們常聽到的<mark>左手換右手</mark>。</li><li>我的策略是<strong>長期持續買進＋領息再投入</strong>，所以我更注重配息的品質，而不只是配多少。</li></ul><hr><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>不是只有現金是錢，資產本身也是錢。<br>如果現金配息最後還是要留在市場，那領現再投入就是左手換右手，還多了匯費、所得稅和交易手續費等等。<br>所以對現階段的我來說，直接保有資產、持續滾動複利，比高配息數字更有價值。</p><hr><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>當然其中還有牽扯一些配息率的問題，不是完全看數字，但大概應該是這個概念，歡迎大家一起討論，<del>雖然留言功能不知道有沒有辦法用</del>。</p><h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul><li><a href="https://www.sinotrade.com.tw/richclub/primary/%E6%94%B6%E7%9B%8A%E5%B9%B3%E6%BA%96%E9%87%91%E6%98%AF%E4%BB%80%E9%BA%BC-%E6%94%B6%E7%9B%8A%E5%B9%B3%E6%BA%96%E9%87%91ETF%E6%9C%89%E5%93%AA%E4%BA%9B-ETF%E9%85%8D%E6%81%AF%E4%BE%86%E6%BA%90-%E6%98%AF%E5%90%A6%E8%AA%B2%E7%A8%85--%E6%94%B6%E7%9B%8A%E5%B9%B3%E6%BA%96%E9%87%91PTT%E8%BF%B7%E6%80%9D%E7%A0%B4%E8%A7%A3-655f0a23b27745268c397396">收益平準金是什麼？ETF 配息來源、是否課稅？</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Finance/理財</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投資</tag>
      
      <tag>ETF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/08/07/hello-world/"/>
    <url>/2025/08/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
