<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Stack and Queue</title>
    <link href="/2025/08/10/data%20structure/stackandqueue/"/>
    <url>/2025/08/10/data%20structure/stackandqueue/</url>
    
    <content type="html"><![CDATA[<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p><img src="/img/datastructure/chapone/1-2.png" alt="Stack"> </p><ul><li>Stack是一種先進後出（Last In First Out, LIFO）的資料結構。它的操作主要有兩個：<ol><li>push：將元素放入堆疊</li><li>pop：將元素從堆疊中取出</li></ol></li></ul><p><img src="/img/datastructure/chapone/1-3.png" alt="Representation of Stack"></p><p><img src="/img/datastructure/chapone/1-4.png" alt="Stack Example"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACKSIZE 100</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stack</span> &#123; <span class="hljs-comment">//宣告一個名為 stack 的結構</span><br>    <span class="hljs-comment">/*Data_Type*/</span><span class="hljs-type">int</span> items[STACKSIZE]; <span class="hljs-comment">// 存放堆疊元素的陣列</span><br>    <span class="hljs-type">int</span> top;    <span class="hljs-comment">// 紀錄目前堆疊頂端的index</span><br>&#125; s;            <span class="hljs-comment">//並同時建立變數 s</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Empty</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stack ps)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ps.top==<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果堆疊為空，返回 1</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 否則返回 0</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stack *ps)</span></span>&#123; <span class="hljs-comment">//回傳的資料型別(data type)是 int</span><br>    <span class="hljs-keyword">return</span> ps-&gt;items[ps-&gt;top--]; <span class="hljs-comment">// 返回堆疊頂端元素並將頂端指標下移</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Pop</code> 會回傳一個元素，因此函式的<strong>回傳型別</strong>為 <code>int</code>（表示會回傳整數）。</li><li><code>Pop</code> 直接操作<strong>原始堆疊</strong>：透過<strong>指標變數</strong> <code>ps</code>（型別為 <code>struct stack *</code>）傳入堆疊 <code>s</code> 的<strong>位址</strong>，函式內以 <code>ps-&gt;</code> 存取成員，會直接修改 <code>s</code>，而不是修改副本。<code>*ps</code> 則是「順著這個指標找到它指向的那個堆疊，整個拿出來看」，<code>ps-&gt;member</code> 等同於 <code>(*ps).member</code>。</li><li><code>ps-&gt;items[ps-&gt;top--]</code> 等價於 <code>(*ps).items[(*ps).top--]</code>：<ul><li><code>ps-&gt;items</code> 是在<strong>存取</strong>堆疊結構中的 <code>items</code> 陣列（不是「指向陣列的指標」的意思）。</li><li><code>ps-&gt;top--</code> 是<strong>後置遞減</strong>：先以目前的 <code>top</code> 做索引，取完值之後 <code>top</code> 再減一。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stack *ps, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    ps-&gt;items[++ps-&gt;top] = x; <span class="hljs-comment">// 將新元素放入堆疊頂端並上移頂端指標</span><br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 無返回值</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Push</code> 的參數 <code>int x</code> 表示要推入的元素型別；<code>struct stack *ps</code> 表示以指標將堆疊的<strong>位址</strong>傳入，函式內直接修改原堆疊內容。</li><li><code>Push</code> 直接操作<strong>原始堆疊</strong>：以指標參數 <code>ps</code>（<code>struct stack *</code>）傳入地址，透過 <code>ps-&gt;</code> 修改成員，不會產生副本。</li><li><code>++ps-&gt;top</code> 會先把 <code>top</code> 加一，再存放元素到新頂端。例如初值 <code>top = -1</code> 時，<code>++ps-&gt;top</code> 變為 <code>0</code>，元素會被放到 <code>items[0]</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Overflow</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stack ps)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ps.top==STACKSIZE<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果堆疊已滿，返回 1</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 否則返回 0</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stack</span> s; <span class="hljs-comment">// 宣告一個全域變數 s，類型為 stack 結構</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    s.top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化堆疊頂端指標為 -1，表示堆疊為空</span><br><br>    <span class="hljs-comment">// 範例操作</span><br>    <span class="hljs-built_in">Push</span>(&amp;s, <span class="hljs-number">10</span>); <span class="hljs-comment">// 將 10 推入堆疊</span><br>    <span class="hljs-built_in">Push</span>(&amp;s, <span class="hljs-number">20</span>); <span class="hljs-comment">// 將 20 推入堆疊</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Empty</span>(s)) &#123; <span class="hljs-comment">// 檢查堆疊是否為空</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆疊為空\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆疊不為空\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;彈出元素: %d\n&quot;</span>, <span class="hljs-built_in">Pop</span>(&amp;s)); <span class="hljs-comment">// 從堆疊彈出頂端元素並顯示</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;彈出元素: %d\n&quot;</span>, <span class="hljs-built_in">Pop</span>(&amp;s)); <span class="hljs-comment">// 再次從堆疊彈出頂端元素並顯示</span><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 程式結束</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在這個範例中，我們宣告了一個全域變數 <code>s</code>，類型為 <code>stack</code> 結構，並在 <code>main</code> 函式中將 <code>top</code> 設為 <code>-1</code> 以表示堆疊為空。接著進行基本操作：推入元素、檢查是否為空、彈出元素。<br>-（補充說明）此檔案同時在結構宣告結尾處以 <code>&#125; s;</code> 建立了變數 <code>s</code>，又在下方寫了 <code>struct stack s;</code>。實務上通常<strong>擇一</strong>即可；本文件保留原始程式碼不調整。</li><li><code>Push(&amp;s, 10)</code>、<code>Pop(&amp;s)</code>：<ul><li><code>&amp;s</code> 代表變數 <code>s</code> 的<strong>記憶體位址</strong>；以位址呼叫，函式會<strong>直接修改原始堆疊</strong>。</li><li><code>Push</code>&#x2F;<code>Pop</code> 的參數型別為 <code>struct stack *ps</code>，<code>ps</code> 會指向原本的 <code>s</code>；在函式內用 <code>ps-&gt;</code>（即 <code>(*ps).</code>）存取成員。</li></ul></li><li>在程式中呼叫 <code>Push(&amp;s, 10)</code> 和 <code>Pop(&amp;s)</code>，就是把堆疊 <code>s</code> 的位址傳入，使 <code>ps</code> 指向原堆疊；因此函式內的修改會反映在 <code>s</code> 上，而不是只改到副本。</li></ul><h2 id="Infix-Postfix-Prefix-Expression"><a href="#Infix-Postfix-Prefix-Expression" class="headerlink" title="Infix, Postfix, Prefix Expression"></a>Infix, Postfix, Prefix Expression</h2><ul><li><strong>Infix Expression</strong>: 操作符位於操作數之間，例如 <code>A + B</code>。</li><li><strong>Postfix Expression</strong>: 操作符位於操作數之後，例如 <code>AB+</code>。也稱為後序表示法。</li><li><strong>Prefix Expression</strong>: 操作符位於操作數之前，例如 <code>+AB</code>。也稱為前序表示法。</li><li>The prefix form is not the mirror image of the postfix form.</li></ul><p><img src="/img/datastructure/chapone/1-5.png"><br><img src="/img/datastructure/chapone/1-5.1.png"></p><ul><li>我們可以先將infix表示式畫成樹狀結構，然後再進行後序或前序的轉換。<ul><li>如果要得到前序(prefix)，只要被路徑經過左邊的node，就寫下來</li><li>如果要得到後序(postfix)，只要被路徑過經右邊的node，就寫下來</li><li>如果要得到中序(infix)，只要被路徑經過下面的node，就寫下來</li></ul></li></ul><p><img src="/img/datastructure/chapone/1-6.png"></p><h3 id="詳細說明與轉換規則"><a href="#詳細說明與轉換規則" class="headerlink" title="詳細說明與轉換規則"></a>詳細說明與轉換規則</h3><h4 id="1-基本觀念"><a href="#1-基本觀念" class="headerlink" title="1) 基本觀念"></a>1) 基本觀念</h4><ul><li><strong>Infix（中序）</strong>：運算子在運算元之間，如 <code>A + B</code></li><li><strong>Postfix（後序&#x2F;逆波蘭表示法）</strong>：運算子在運算元之後，如 <code>A B +</code></li><li><strong>Prefix（前序&#x2F;波蘭表示法）</strong>：運算子在運算元之前，如 <code>+ A B</code></li></ul><h4 id="2-優先序與結合性"><a href="#2-優先序與結合性" class="headerlink" title="2) 優先序與結合性"></a>2) 優先序與結合性</h4><table><thead><tr><th>符號</th><th align="right">優先序（高→低）</th><th>結合性</th></tr></thead><tbody><tr><td><code>^</code></td><td align="right">3</td><td>右結合</td></tr><tr><td><code>*</code>、<code>/</code></td><td align="right">2</td><td>左結合</td></tr><tr><td><code>+</code>、<code>-</code>（binary）</td><td align="right">1</td><td>左結合</td></tr><tr><td><code>(</code>、<code>)</code></td><td align="right">括號用於覆寫優先序</td><td></td></tr></tbody></table><blockquote><p><code>^</code>（指數）為<strong>右結合</strong>，遇到相同優先時不要先彈出棧頂。</p></blockquote><h4 id="3-Infix-→-Postfix-演算法"><a href="#3-Infix-→-Postfix-演算法" class="headerlink" title="3) Infix → Postfix 演算法"></a>3) Infix → Postfix 演算法</h4><ol><li>運算元 → 直接輸出。</li><li>左括號 <code>(</code> → 推入運算子堆疊。</li><li>右括號 <code>)</code> → 不斷彈出運算子到輸出，直到遇到左括號為止（左括號不輸出）。</li><li>一般運算子 <code>op</code> →  <ul><li>當棧頂運算子優先序 &gt; <code>op</code>，或（優先序相等且 <code>op</code> 為左結合）時，彈出棧頂到輸出。</li><li>然後將 <code>op</code> 推入堆疊。</li></ul></li><li>掃描完成後 → 將堆疊中剩餘的運算子全部彈出到輸出。</li></ol><h4 id="4-Infix-→-Prefix-方法"><a href="#4-Infix-→-Prefix-方法" class="headerlink" title="4) Infix → Prefix 方法"></a>4) Infix → Prefix 方法</h4><ul><li><strong>方法1（反轉法）</strong>：反轉字串 → 交換括號 → 按 Infix→Postfix 規則轉換 → 反轉結果。</li><li><strong>方法2（運算樹法）</strong>：建構運算樹，再做 Preorder 走訪。</li></ul><h4 id="5-Postfix-求值"><a href="#5-Postfix-求值" class="headerlink" title="5) Postfix 求值"></a>5) Postfix 求值</h4><ol><li>遇到運算元 → 推入運算元堆疊。</li><li>遇到運算子 → 彈出兩個運算元（先右再左），計算後將結果推回堆疊。</li><li>掃描完成後堆疊頂即為結果。</li></ol><blockquote><p>Prefix 求值可由右往左掃描，邏輯與 Postfix 類似。</p></blockquote><h4 id="6-常見陷阱"><a href="#6-常見陷阱" class="headerlink" title="6) 常見陷阱"></a>6) 常見陷阱</h4><ul><li>注意右結合運算子的處理規則。</li><li>區分一元與二元運算子（例如 <code>-x</code> 與 <code>a - b</code>）。</li><li>括號不會出現在最終的 Postfix&#x2F;Prefix 表示式中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
      <tag>stack</tag>
      
      <tag>queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0050 v.s. 006208</title>
    <link href="/2025/08/08/006208/"/>
    <url>/2025/08/08/006208/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近收到006208的配息，就想到當初看完 <a href="https://www.books.com.tw/products/0010957881?sloc=main"><strong>持續買進</strong></a> 和 <a href="https://www.books.com.tw/products/0010955845?sloc=main"><strong>漫步華爾街</strong></a> 後，重新想了一下自己目前的的投資策略到底是怎，然後從原本定期定額的<strong>0050</strong>，轉向<strong>006208</strong>。</p><hr><h2 id="我的投資策略：長期持續買進"><a href="#我的投資策略：長期持續買進" class="headerlink" title="我的投資策略：長期持續買進"></a>我的投資策略：長期持續買進</h2><p>我的投資核心理念很簡單：<strong>不猜市場高低點，持續投入資金，讓資產穩定累積並抵抗通膨</strong>。</p><hr><h2 id="為什麼在0050和006208中選擇後者"><a href="#為什麼在0050和006208中選擇後者" class="headerlink" title="為什麼在0050和006208中選擇後者"></a>為什麼在0050和006208中選擇後者</h2><p>雖然0050和006208都是台股市值型的大盤ETF，成分股高度重疊，但配息來源結構是我選006208的原因。</p><h3 id="配息來源比較"><a href="#配息來源比較" class="headerlink" title="配息來源比較"></a>配息來源比較</h3><ul><li><strong>006208</strong>：配息<strong>100%來自54C（股利所得）</strong>，這代表配給我的現金，是真正來自成分股公司營運賺到的錢。資產本體（股票）依然留在市場中，繼續享受未來漲幅與股息。</li><li><strong>0050</strong>：配息中有一部分來自 <strong>76（資本利得）</strong>，意思是ETF賣掉一部分持股，把賣股票的價差配回給投資人。雖然資本利得在台灣不用課所得稅(<del>雖然我還不用繳所得稅</del>)，但對我來說，如果我不想在這個時候賣股，這筆配息等於減少了ETF的持股部位，<strong>犧牲未來的成長空間來換現金</strong>。對我這種現階段不需要額外現金流的人來說，這是資產淨值、時間成本、甚至是手續費的損失。</li></ul><h3 id="為什麼我在意配息來源"><a href="#為什麼我在意配息來源" class="headerlink" title="為什麼我在意配息來源"></a>為什麼我在意配息來源</h3><ul><li><strong>54C的好處</strong>：資產本體還在市場中運作，沒有被動用或減少持股，保有長期成長潛力與複利效果。</li><li><strong>76 的問題</strong>：減少持股，相當於提前套現一部分資產，長期來看是成長動能的流失。</li><li><strong>複利影響</strong>：若配息後沒有立即再投入，複利效果會被切斷；即使全額投入，也會遇到現金停留時間（領息到再買回）、交易手續費等額外成本，就是我們常聽到的<mark>左手換右手</mark>。</li><li>我的策略是<strong>長期持續買進＋領息再投入</strong>，所以我更注重配息的品質，而不只是配多少。</li></ul><hr><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>不是只有現金是錢，資產本身也是錢。<br>如果現金配息最後還是要留在市場，那領現再投入就是左手換右手，還多了匯費、所得稅和交易手續費等等。<br>所以對現階段的我來說，直接保有資產、持續滾動複利，比高配息數字更有價值。</p><hr><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>當然其中還有牽扯一些配息率的問題，不是完全看數字，但大概應該是這個概念，歡迎大家一起討論，<del>雖然留言功能不知道有沒有辦法用</del>。</p><h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul><li><a href="https://www.sinotrade.com.tw/richclub/primary/%E6%94%B6%E7%9B%8A%E5%B9%B3%E6%BA%96%E9%87%91%E6%98%AF%E4%BB%80%E9%BA%BC-%E6%94%B6%E7%9B%8A%E5%B9%B3%E6%BA%96%E9%87%91ETF%E6%9C%89%E5%93%AA%E4%BA%9B-ETF%E9%85%8D%E6%81%AF%E4%BE%86%E6%BA%90-%E6%98%AF%E5%90%A6%E8%AA%B2%E7%A8%85--%E6%94%B6%E7%9B%8A%E5%B9%B3%E6%BA%96%E9%87%91PTT%E8%BF%B7%E6%80%9D%E7%A0%B4%E8%A7%A3-655f0a23b27745268c397396">收益平準金是什麼？ETF 配息來源、是否課稅？</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Finance/理財</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投資</tag>
      
      <tag>ETF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/08/07/hello-world/"/>
    <url>/2025/08/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
