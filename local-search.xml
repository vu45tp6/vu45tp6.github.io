<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Stack and Queue</title>
    <link href="/2025/08/10/data%20structure/stackandqueue/"/>
    <url>/2025/08/10/data%20structure/stackandqueue/</url>
    
    <content type="html"><![CDATA[<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p><img src="/img/datastructure/chapone/1-2.png" alt="Stack"> </p><ul><li>Stack是一種先進後出（Last In First Out, LIFO）的資料結構。它的操作主要有兩個：<ol><li>push：將元素放入堆疊</li><li>pop：將元素從堆疊中取出</li></ol></li></ul><p><img src="/img/datastructure/chapone/1-3.png" alt="Representation of Stack"></p><p><img src="/img/datastructure/chapone/1-4.png" alt="Stack Example"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACKSIZE 100</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stack</span> &#123; <span class="hljs-comment">//宣告一個名為 stack 的結構</span><br>    <span class="hljs-comment">/*Data_Type*/</span><span class="hljs-type">int</span> items[STACKSIZE]; <span class="hljs-comment">// 存放堆疊元素的陣列</span><br>    <span class="hljs-type">int</span> top;    <span class="hljs-comment">// 紀錄目前堆疊頂端的index</span><br>&#125; s;            <span class="hljs-comment">//並同時建立變數 s</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Empty</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stack ps)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ps.top==<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果堆疊為空，返回 1</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 否則返回 0</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Pop</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stack *ps)</span></span>&#123; <span class="hljs-comment">//回傳的資料型別(data type)是 int</span><br>    <span class="hljs-keyword">return</span> ps-&gt;items[ps-&gt;top--]; <span class="hljs-comment">// 返回堆疊頂端元素並將頂端指標下移</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Pop</code> 會回傳一個元素，因此函式的<strong>回傳型別</strong>為 <code>int</code>（表示會回傳整數）。</li><li><code>Pop</code> 直接操作<strong>原始堆疊</strong>：透過<strong>指標變數</strong> <code>ps</code>（型別為 <code>struct stack *</code>）傳入堆疊 <code>s</code> 的<strong>位址</strong>，函式內以 <code>ps-&gt;</code> 存取成員，會直接修改 <code>s</code>，而不是修改副本。<code>*ps</code> 則是「順著這個指標找到它指向的那個堆疊，整個拿出來看」，<code>ps-&gt;member</code> 等同於 <code>(*ps).member</code>。</li><li><code>ps-&gt;items[ps-&gt;top--]</code> 等價於 <code>(*ps).items[(*ps).top--]</code>：<ul><li><code>ps-&gt;items</code> 是在<strong>存取</strong>堆疊結構中的 <code>items</code> 陣列（不是「指向陣列的指標」的意思）。</li><li><code>ps-&gt;top--</code> 是<strong>後置遞減</strong>：先以目前的 <code>top</code> 做索引，取完值之後 <code>top</code> 再減一。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stack *ps, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    ps-&gt;items[++ps-&gt;top] = x; <span class="hljs-comment">// 將新元素放入堆疊頂端並上移頂端指標</span><br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 無返回值</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Push</code> 的參數 <code>int x</code> 表示要推入的元素型別；<code>struct stack *ps</code> 表示以指標將堆疊的<strong>位址</strong>傳入，函式內直接修改原堆疊內容。</li><li><code>Push</code> 直接操作<strong>原始堆疊</strong>：以指標參數 <code>ps</code>（<code>struct stack *</code>）傳入地址，透過 <code>ps-&gt;</code> 修改成員，不會產生副本。</li><li><code>++ps-&gt;top</code> 會先把 <code>top</code> 加一，再存放元素到新頂端。例如初值 <code>top = -1</code> 時，<code>++ps-&gt;top</code> 變為 <code>0</code>，元素會被放到 <code>items[0]</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Overflow</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> stack ps)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(ps.top==STACKSIZE<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果堆疊已滿，返回 1</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 否則返回 0</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stack</span> s; <span class="hljs-comment">// 宣告一個全域變數 s，類型為 stack 結構</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    s.top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化堆疊頂端指標為 -1，表示堆疊為空</span><br><br>    <span class="hljs-comment">// 範例操作</span><br>    <span class="hljs-built_in">Push</span>(&amp;s, <span class="hljs-number">10</span>); <span class="hljs-comment">// 將 10 推入堆疊</span><br>    <span class="hljs-built_in">Push</span>(&amp;s, <span class="hljs-number">20</span>); <span class="hljs-comment">// 將 20 推入堆疊</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Empty</span>(s)) &#123; <span class="hljs-comment">// 檢查堆疊是否為空</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆疊為空\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆疊不為空\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;彈出元素: %d\n&quot;</span>, <span class="hljs-built_in">Pop</span>(&amp;s)); <span class="hljs-comment">// 從堆疊彈出頂端元素並顯示</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;彈出元素: %d\n&quot;</span>, <span class="hljs-built_in">Pop</span>(&amp;s)); <span class="hljs-comment">// 再次從堆疊彈出頂端元素並顯示</span><br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 程式結束</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在這個範例中，我們宣告了一個全域變數 <code>s</code>，類型為 <code>stack</code> 結構，並在 <code>main</code> 函式中將 <code>top</code> 設為 <code>-1</code> 以表示堆疊為空。接著進行基本操作：推入元素、檢查是否為空、彈出元素。<br>-（補充說明）此檔案同時在結構宣告結尾處以 <code>&#125; s;</code> 建立了變數 <code>s</code>，又在下方寫了 <code>struct stack s;</code>。實務上通常<strong>擇一</strong>即可；本文件保留原始程式碼不調整。</li><li><code>Push(&amp;s, 10)</code>、<code>Pop(&amp;s)</code>：<ul><li><code>&amp;s</code> 代表變數 <code>s</code> 的<strong>記憶體位址</strong>；以位址呼叫，函式會<strong>直接修改原始堆疊</strong>。</li><li><code>Push</code>&#x2F;<code>Pop</code> 的參數型別為 <code>struct stack *ps</code>，<code>ps</code> 會指向原本的 <code>s</code>；在函式內用 <code>ps-&gt;</code>（即 <code>(*ps).</code>）存取成員。</li></ul></li><li>在程式中呼叫 <code>Push(&amp;s, 10)</code> 和 <code>Pop(&amp;s)</code>，就是把堆疊 <code>s</code> 的位址傳入，使 <code>ps</code> 指向原堆疊；因此函式內的修改會反映在 <code>s</code> 上，而不是只改到副本。</li></ul><h2 id="Infix-Postfix-Prefix-Expression"><a href="#Infix-Postfix-Prefix-Expression" class="headerlink" title="Infix, Postfix, Prefix Expression"></a>Infix, Postfix, Prefix Expression</h2><p><img src="/img/datastructure/chapone/1-5.png"></p><ul><li><strong>Infix Expression</strong>: 操作符位於操作數之間，例如 <code>A + B</code>。</li><li><strong>Postfix Expression</strong>: 操作符位於操作數之後，例如 <code>AB+</code>（後序表示法）。</li><li><strong>Prefix Expression</strong>: 操作符位於操作數之前，例如 <code>+AB</code>（前序表示法）。</li><li>The prefix form is not the mirror image of the postfix form.</li></ul><p><img src="/img/datastructure/chapone/1-5.1.png"></p><ul><li>我們可以先將 infix 表示式畫成運算樹，然後再進行後序或前序的轉換。<ul><li>前序(prefix)：Preorder 走訪（先訪問節點，再走訪左右子樹）。</li><li>後序(postfix)：Postorder 走訪（先走訪左右子樹，最後訪問節點）。</li><li>中序(infix)：Inorder 走訪（先走訪左子樹，訪問節點，再走訪右子樹）。</li></ul></li></ul><p><img src="/img/datastructure/chapone/1-6.png"></p><h3 id="In-Stack-Priority-ISP-與-In-Coming-Priority-ICP"><a href="#In-Stack-Priority-ISP-與-In-Coming-Priority-ICP" class="headerlink" title="In-Stack Priority (ISP) 與 In-Coming Priority (ICP)"></a>In-Stack Priority (ISP) 與 In-Coming Priority (ICP)</h3><p>在將 <strong>Infix</strong> 轉成 <strong>Postfix</strong> 時，需比較：</p><ul><li><strong>ISP</strong>（In-Stack Priority）：已經在堆疊中的運算子優先序</li><li><strong>ICP</strong>（In-Coming Priority）：剛讀入、準備進堆疊的運算子優先序</li></ul><p><strong>判斷規則</strong>  </p><ul><li>若 <code>ISP(top) ≥ ICP(token)</code> → 先把棧(堆疊)頂運算子彈出到輸出  </li><li>否則 → 將新運算子推入堆疊  </li><li>特殊情況：<ul><li><code>)</code>：不比優先序，直接彈出直到遇到 <code>(</code>  </li><li><code>(</code>：直接推入（保護內層運算）</li><li><code>^</code>（冪次）設定成右結合 → <code>ICP(^) &gt; ISP(^)</code>，遇到同級 <code>^</code> 不會先彈出</li></ul></li></ul><table><thead><tr><th>符號</th><th align="right">ISP（棧內）</th><th align="right">ICP（新進）</th><th>說明</th></tr></thead><tbody><tr><td><code>)</code></td><td align="right">特殊處理</td><td align="right">特殊處理</td><td>用於彈出到左括號</td></tr><tr><td><code>^</code></td><td align="right">3</td><td align="right">4</td><td>右結合：同級時不先彈出</td></tr><tr><td><code>*</code>、<code>/</code></td><td align="right">2</td><td align="right">2</td><td>左結合</td></tr><tr><td><code>+</code>、<code>-</code>（二元）</td><td align="right">1</td><td align="right">1</td><td>左結合</td></tr><tr><td><code>(</code></td><td align="right">0</td><td align="right">4</td><td>直接進棧，不與其他比較</td></tr></tbody></table><blockquote><p><strong>一元運算子(Unary) (<code>+x</code>, <code>-x</code>) 處理</strong><br>需在詞法或語法階段辨識，可：</p><ul><li>將其直接合併到常數（如 <code>-5</code> 當作運算元）  </li><li>視為獨立一元運算子，給比二元運算子更高的優先序</li></ul></blockquote><hr><h3 id="Evaluate-Subvalue"><a href="#Evaluate-Subvalue" class="headerlink" title="Evaluate_Subvalue"></a>Evaluate_Subvalue</h3><p>函式用途：計算一次子表達式，並將結果推回運算元堆疊。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pseudo">Evaluate_Subvalue( Operator_type OP ) //宣告函式，`OP` 為運算子類型(例如 `+`, `-`, `*`, `/`)<br>&#123;<br>    /* print OP to screen -&gt; display */<br>    Pop two elements a, b of operand_stack; //從運算元堆疊彈出兩個元素 a 和 b(先pop出右運算元b，再pop出左運算元a)<br>    new_value = Do_Operate( a, OP, b ); //執行運算，計算結果存入 new_value<br>    Push new_value into operand_stack; //將計算結果推回運算元堆疊<br>&#125; /* End of Evaluate_Subvalue */<br></code></pre></td></tr></table></figure><p><img src="/img/datastructure/chapone/1-7.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs pseudo">## Infix 直接求值（兩堆疊法）<br><br>```pseudo<br>Input_infix_expression                   // 讀入一個中序算式<br>operator_stack ← empty stack              // 運算子堆疊（存 + - * / ^ 等符號）<br>operand_stack  ← empty stack              // 運算元堆疊（存數字或變數值）<br><br>while (not End_of_infix) &#123;                // 從左到右掃描整個算式<br>  symb ← Next_Token(from input_infix)     // 取得下一個 token<br><br>  if (symb is an operand) &#123;               // 若是運算元（數字或變數）<br>    /* print symb to screen → display */  // 可印出作為轉 Postfix 的輸出過程<br>    Push(operand_stack, symb)             // 壓入運算元堆疊<br>  &#125;<br>  else &#123;                                  // 否則是運算子或括號<br>    if (symb == &#x27;)&#x27;) &#123;                    // 遇到右括號 → 開始彈出直到左括號<br>      while ( (OP = Pop(operator_stack)) != &#x27;(&#x27; ) &#123;<br>        Evaluate_Subvalue(OP)             // 每彈一個運算子就計算一次<br>      &#125;<br>      continue                            // &#x27;)&#x27; 不進堆疊，處理下一個 token<br>    &#125;<br><br>    // 一般運算子：用 ICP/ISP 規則判斷是否先計算棧頂<br>    while (Prio_Less_Equ(symb, StackTop(operator_stack))) &#123;<br>      OP ← Pop(operator_stack)            // 彈出棧頂運算子（Call by value）<br>      Evaluate_Subvalue(OP)               // 用 OP 從 operand_stack 取左右運算元計算並推回<br>    &#125;<br>    Push(operator_stack, symb)            // 當前運算子進棧<br>  &#125;<br>&#125;<br><br>// 掃描結束後，把剩餘運算子依序算完<br>while (not Empty(operator_stack)) &#123;<br>  OP ← Pop(operator_stack)<br>  Evaluate_Subvalue(OP)<br>&#125;<br><br>// 最終結果即在運算元堆疊頂端<br>Print(StackTop(operand_stack))            // 印出計算結果<br></code></pre></td></tr></table></figure><p>Evaluate_Subvalue(OP)：先從 operand_stack 彈出右運算元，再彈出左運算元，計算 left OP right，將結果推回堆疊。</p><p>Prio_Less_Equ(a, b)：比較新來運算子 a 的 ICP 與棧頂運算子 b 的 ISP；若 ISP(b) ≥ ICP(a)，則 b 先算。</p><p>右結合的 ^：透過設定 ICP(^) &gt; ISP(^) 避免同級時提前彈出，形成 a ^ (b ^ c)。</p><p>一元運算子（+&#x2F;-）：需在斷詞&#x2F;語法分析階段先辨識，通常給比二元更高的 ICP 以避免誤判。</p><h3 id="範例一：-A-C-B"><a href="#範例一：-A-C-B" class="headerlink" title="範例一：(A + C) * B"></a>範例一：(A + C) * B</h3><p>Tokens: <code>(</code> <code>A</code> <code>+</code> <code>C</code> <code>)</code> <code>*</code> <code>B</code></p><table><thead><tr><th>Token</th><th>運算子堆疊</th><th>輸出</th></tr></thead><tbody><tr><td>(</td><td>(</td><td></td></tr><tr><td>A</td><td>(</td><td>A</td></tr><tr><td>+</td><td>( +</td><td>A</td></tr><tr><td>C</td><td>( +</td><td>A C</td></tr><tr><td>)</td><td>( → pop <code>+</code></td><td>A C +</td></tr><tr><td>*</td><td>*</td><td>A C +</td></tr><tr><td>B</td><td>*</td><td>A C + B</td></tr><tr><td>end</td><td></td><td>A C + B *</td></tr></tbody></table><p>Postfix: <code>A C + B *</code></p><h3 id="範例二-完整-1-7-範例"><a href="#範例二-完整-1-7-範例" class="headerlink" title="範例二 (完整 1-7 範例)"></a>範例二 (完整 1-7 範例)</h3><p>Infix: <code>3 + 5 * 7 - ( 2 ^ 3 - 3 * 4 - ( 1 * 2 ) )</code></p><table><thead><tr><th>Token</th><th>運算子堆疊</th><th>輸出(Postfix)</th></tr></thead><tbody><tr><td>3</td><td></td><td>3</td></tr><tr><td>+</td><td>+</td><td>3</td></tr><tr><td>5</td><td>+</td><td>3 5</td></tr><tr><td>*</td><td>+ *</td><td>3 5</td></tr><tr><td>7</td><td>+ *</td><td>3 5 7</td></tr><tr><td>-</td><td>-</td><td>3 5 7 * +</td></tr><tr><td>(</td><td>- (</td><td>3 5 7 * +</td></tr><tr><td>2</td><td>- (</td><td>3 5 7 * + 2</td></tr><tr><td>^</td><td>- ( ^</td><td>3 5 7 * + 2</td></tr><tr><td>3</td><td>- ( ^</td><td>3 5 7 * + 2 3</td></tr><tr><td>-</td><td>- ( -</td><td>3 5 7 * + 2 3 ^</td></tr><tr><td>3</td><td>- ( -</td><td>3 5 7 * + 2 3 ^ 3</td></tr><tr><td>*</td><td>- ( - *</td><td>3 5 7 * + 2 3 ^ 3</td></tr><tr><td>4</td><td>- ( - *</td><td>3 5 7 * + 2 3 ^ 3 4</td></tr><tr><td>-</td><td>- ( -</td><td>3 5 7 * + 2 3 ^ 3 4 * -</td></tr><tr><td>(</td><td>- ( - (</td><td>3 5 7 * + 2 3 ^ 3 4 * -</td></tr><tr><td>1</td><td>- ( - (</td><td>3 5 7 * + 2 3 ^ 3 4 * - 1</td></tr><tr><td>*</td><td>- ( - ( *</td><td>3 5 7 * + 2 3 ^ 3 4 * - 1</td></tr><tr><td>2</td><td>- ( - ( *</td><td>3 5 7 * + 2 3 ^ 3 4 * - 1 2</td></tr><tr><td>)</td><td>- ( -</td><td>3 5 7 * + 2 3 ^ 3 4 * - 1 2 *</td></tr><tr><td>)</td><td>-</td><td>3 5 7 * + 2 3 ^ 3 4 * - 1 2 * -</td></tr><tr><td>end</td><td></td><td>3 5 7 * + 2 3 ^ 3 4 * - 1 2 * - -</td></tr></tbody></table><p>Postfix: <code>3 5 7 * + 2 3 ^ 3 4 * - 1 2 * - -</code></p><h3 id="Postfix-求值"><a href="#Postfix-求值" class="headerlink" title="Postfix 求值"></a>Postfix 求值</h3><p>演算法：</p><ol><li>由左到右讀取 token</li><li>運算元 → 推入值堆疊</li><li>運算子 → 依序彈出<strong>右運算元</strong>與<strong>左運算元</strong>，計算後推回堆疊</li><li>結束時堆疊頂即為答案</li></ol><p>範例計算：</p><ul><li><code>5 7 * → 35</code>，<code>3 35 + → 38</code></li><li><code>2 3 ^ → 8</code>，<code>3 4 * → 12</code>，<code>8 12 - → -4</code></li><li><code>1 2 * → 2</code>，<code>-4 2 - → -6</code></li><li><code>38 (-6) - → 44</code></li></ul><p>結果：<strong>44</strong></p><p><img src="/img/datastructure/chapone/1-8.png"></p><h2 id="Example-Mazing-Problem（迷宮問題）"><a href="#Example-Mazing-Problem（迷宮問題）" class="headerlink" title="Example: Mazing Problem（迷宮問題）"></a>Example: Mazing Problem（迷宮問題）</h2><h3 id="問題說明"><a href="#問題說明" class="headerlink" title="問題說明"></a>問題說明</h3><ul><li><strong>MAZE[M+2][N+2]</strong>：儲存迷宮的地圖（含邊界資訊）。<ul><li><code>MAZE[i][j] == 1</code> 代表該格無法通行（牆或邊界）。</li><li>邊界本身也是視為不可通行。</li></ul></li><li><strong>MARK[M+2][N+2]</strong>：<ul><li>初始值為 <code>0</code>。</li><li>當走到該位置時設為 <code>1</code>（表示已訪問）。</li></ul></li><li><strong>堆疊（stack）</strong> 內存放三個資訊：<ol><li><code>i</code>：目前所在列座標</li><li><code>j</code>：目前所在行座標</li><li><code>mov</code>：下一個搜尋方向編號</li></ol></li><li><strong>MOV[8][2]</strong>：8 個方向的位移量（row offset, col offset）。<ul><li>方向對應：<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>: N  ( -<span class="hljs-number">1</span>,  <span class="hljs-number">0</span> )<br><span class="hljs-attribute">1</span>: NE ( -<span class="hljs-number">1</span>, +<span class="hljs-number">1</span> )<br><span class="hljs-attribute">2</span>: E  (  <span class="hljs-number">0</span>, +<span class="hljs-number">1</span> )<br><span class="hljs-attribute">3</span>: SE ( +<span class="hljs-number">1</span>, +<span class="hljs-number">1</span> )<br><span class="hljs-attribute">4</span>: S  ( +<span class="hljs-number">1</span>,  <span class="hljs-number">0</span> )<br><span class="hljs-attribute">5</span>: SW ( +<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> )<br><span class="hljs-attribute">6</span>: W  (  <span class="hljs-number">0</span>, -<span class="hljs-number">1</span> )<br><span class="hljs-attribute">7</span>: NW ( -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span> )<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>起點</strong>：<code>MAZE[1][1]</code>，第一個搜尋方向為東（<code>mov = 2</code>）。</li></ul><hr><h3 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode"></a>Pseudocode</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pseudo">Push( (1, 1, 2), stack )                // 起點座標 (i=1, j=1) 與初始方向 mov=2<br><br>while (stack not empty) &#123;<br>    (i, j, mov) = Pop(stack)             // 取出當前位置與下一方向<br><br>    while (還有未嘗試的方向) &#123;<br>        (g, h) = coordinates of next move  // 根據 mov 取得下一步座標<br><br>        if ((g, h) == (m, n)) &#123;           // 到達終點<br>            // Success: stack 內容即為路徑<br>            輸出路徑<br>            return<br>        &#125;<br><br>        // 若該位置可走且尚未標記<br>        if (MAZE[g][h] != 1 &amp;&amp; MARK[g][h] == 0) &#123;<br>            MARK[g][h] = 1                // 標記已訪問<br>            Push( (i, j, mov), stack )    // 保存當前狀態（方便回溯）<br>            (i, j, mov) = (g, h, 0)       // 移動到新位置，方向重置為 0<br>        &#125;<br>        else &#123;<br>            mov = mov + 1                 // 換下一個方向嘗試<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="流程說明"><a href="#流程說明" class="headerlink" title="流程說明"></a>流程說明</h3><ol><li><p><strong>Push 起點資訊</strong> <code>(1, 1, 2)</code> 進堆疊：  </p><ul><li><code>(i, j) = (1, 1)</code> 為起點  </li><li><code>mov = 2</code> 表示第一個嘗試方向為東（E）</li></ul></li><li><p><strong>主迴圈</strong>：只要堆疊不空，表示還有可能的路徑待探索。  </p><ul><li><strong>Pop</strong>：取出堆疊頂端的座標與方向。  </li><li><strong>內層 while</strong>：嘗試從當前位置往各方向探索：  <ul><li>根據 <code>mov</code> 查表得到 <code>(g, h)</code> 下一格座標。  </li><li>如果 <code>(g, h)</code> 是出口 <code>(m, n)</code> → 成功，輸出堆疊內容（即路徑）。  </li><li>如果該格可走 (<code>MAZE[g][h] != 1</code>) 且尚未訪問 (<code>MARK[g][h] == 0</code>)：  <ul><li>標記為已訪問。  </li><li>把當前狀態 <code>(i, j, mov)</code> 推回堆疊（方便之後回溯）。  </li><li>將 <code>(i, j)</code> 更新為 <code>(g, h)</code>，方向 <code>mov</code> 重置為 0（從新位置的第一個方向開始）。</li></ul></li><li>否則 → <code>mov++</code>，嘗試下一方向。</li></ul></li></ul></li><li><p><strong>迴圈結束</strong>：若堆疊清空仍沒找到出口，表示無路可走。</p></li></ol><hr><h3 id="重點"><a href="#重點" class="headerlink" title="重點"></a>重點</h3><ul><li>使用 <strong>DFS（深度優先搜尋）</strong> 搭配堆疊實作。  </li><li><code>MARK</code> 用來避免重複走訪相同格子。  </li><li>堆疊保存「走過的路徑」以及「當前位置未探索完的方向」，方便回溯。  </li><li>成功時，堆疊的內容就是一條走到出口的路徑。</li></ul>]]></content>
    
    
    <categories>
      
      <category>data structure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data structure</tag>
      
      <tag>stack</tag>
      
      <tag>queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0050 v.s. 006208</title>
    <link href="/2025/08/08/006208/"/>
    <url>/2025/08/08/006208/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近收到006208的配息，就想到當初看完 <a href="https://www.books.com.tw/products/0010957881?sloc=main"><strong>持續買進</strong></a> 和 <a href="https://www.books.com.tw/products/0010955845?sloc=main"><strong>漫步華爾街</strong></a> 後，重新想了一下自己目前的的投資策略到底是怎，然後從原本定期定額的<strong>0050</strong>，轉向<strong>006208</strong>。</p><hr><h2 id="我的投資策略：長期持續買進"><a href="#我的投資策略：長期持續買進" class="headerlink" title="我的投資策略：長期持續買進"></a>我的投資策略：長期持續買進</h2><p>我的投資核心理念很簡單：<strong>不猜市場高低點，持續投入資金，讓資產穩定累積並抵抗通膨</strong>。</p><hr><h2 id="為什麼在0050和006208中選擇後者"><a href="#為什麼在0050和006208中選擇後者" class="headerlink" title="為什麼在0050和006208中選擇後者"></a>為什麼在0050和006208中選擇後者</h2><p>雖然0050和006208都是台股市值型的大盤ETF，成分股高度重疊，但配息來源結構是我選006208的原因。</p><h3 id="配息來源比較"><a href="#配息來源比較" class="headerlink" title="配息來源比較"></a>配息來源比較</h3><ul><li><strong>006208</strong>：配息<strong>100%來自54C（股利所得）</strong>，這代表配給我的現金，是真正來自成分股公司營運賺到的錢。資產本體（股票）依然留在市場中，繼續享受未來漲幅與股息。</li><li><strong>0050</strong>：配息中有一部分來自 <strong>76（資本利得）</strong>，意思是ETF賣掉一部分持股，把賣股票的價差配回給投資人。雖然資本利得在台灣不用課所得稅(<del>雖然我還不用繳所得稅</del>)，但對我來說，如果我不想在這個時候賣股，這筆配息等於減少了ETF的持股部位，<strong>犧牲未來的成長空間來換現金</strong>。對我這種現階段不需要額外現金流的人來說，這是資產淨值、時間成本、甚至是手續費的損失。</li></ul><h3 id="為什麼我在意配息來源"><a href="#為什麼我在意配息來源" class="headerlink" title="為什麼我在意配息來源"></a>為什麼我在意配息來源</h3><ul><li><strong>54C的好處</strong>：資產本體還在市場中運作，沒有被動用或減少持股，保有長期成長潛力與複利效果。</li><li><strong>76 的問題</strong>：減少持股，相當於提前套現一部分資產，長期來看是成長動能的流失。</li><li><strong>複利影響</strong>：若配息後沒有立即再投入，複利效果會被切斷；即使全額投入，也會遇到現金停留時間（領息到再買回）、交易手續費等額外成本，就是我們常聽到的<mark>左手換右手</mark>。</li><li>我的策略是<strong>長期持續買進＋領息再投入</strong>，所以我更注重配息的品質，而不只是配多少。</li></ul><hr><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>不是只有現金是錢，資產本身也是錢。<br>如果現金配息最後還是要留在市場，那領現再投入就是左手換右手，還多了匯費、所得稅和交易手續費等等。<br>所以對現階段的我來說，直接保有資產、持續滾動複利，比高配息數字更有價值。</p><hr><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>當然其中還有牽扯一些配息率的問題，不是完全看數字，但大概應該是這個概念，歡迎大家一起討論，<del>雖然留言功能不知道有沒有辦法用</del>。</p><h2 id="參考文章"><a href="#參考文章" class="headerlink" title="參考文章"></a>參考文章</h2><ul><li><a href="https://www.sinotrade.com.tw/richclub/primary/%E6%94%B6%E7%9B%8A%E5%B9%B3%E6%BA%96%E9%87%91%E6%98%AF%E4%BB%80%E9%BA%BC-%E6%94%B6%E7%9B%8A%E5%B9%B3%E6%BA%96%E9%87%91ETF%E6%9C%89%E5%93%AA%E4%BA%9B-ETF%E9%85%8D%E6%81%AF%E4%BE%86%E6%BA%90-%E6%98%AF%E5%90%A6%E8%AA%B2%E7%A8%85--%E6%94%B6%E7%9B%8A%E5%B9%B3%E6%BA%96%E9%87%91PTT%E8%BF%B7%E6%80%9D%E7%A0%B4%E8%A7%A3-655f0a23b27745268c397396">收益平準金是什麼？ETF 配息來源、是否課稅？</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Finance/理財</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投資</tag>
      
      <tag>ETF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/08/07/hello-world/"/>
    <url>/2025/08/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
